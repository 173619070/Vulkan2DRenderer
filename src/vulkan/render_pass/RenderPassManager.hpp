#pragma once

#include <core/SourceCommon.hpp>
#include "RenderPassHandle.hpp"
#include "RenderPassManagerRenderPassEntry.hpp"
#include <types/Synchronization.hpp>
#include "RenderPassCreateInfo.hpp"



namespace vk2d {
namespace vk2d_internal {

class InstanceImpl;

} // vk2d_internal

namespace vulkan {

class Device;



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class RenderPassManager
{
	friend class RenderPassCompiler;
	friend class RenderPassHandle;

public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TODO: Find better ways to implement a hash map. eg. std::flat_map. Mind pointer invalidation though.
	using RenderPassList = std::map<size_t, RenderPassManagerRenderPassEntry>;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	RenderPassManager(
		vk2d_internal::InstanceImpl					&	instance,
		Device										&	vulkan_device
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	RenderPassManager(
		const RenderPassManager						&	other
	) = delete;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	RenderPassManager(
		RenderPassManager							&&	other
	) = delete;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	~RenderPassManager();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @brief		Tries to find a render pass and return a handle to it if it exists.
	///
	/// @param		render_pass_create_info
	///				Render pass create info structure describing the Vulkan render pass we want to find.
	///
	/// @return		Handle to existing render pass or empty handle if render pass was not found.
	RenderPassHandle									FindRenderPass(
		const RenderPassCreateInfo					&	render_pass_create_info
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @brief		Tries to find a render pass and return a handle to it if it exists.
	///
	/// @param		render_pass_hash
	///				Hash of the render pass we wish to find.
	///
	/// @return		Handle to existing render pass or empty handle if render pass was not found.
	RenderPassHandle									FindRenderPass(
		size_t											render_pass_hash
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @brief		Gets a render pass if it exists or creates a new render pass if it does not exist.
	///
	/// @param[in]	render_pass_create_info
	///				RenderPass create info structure describing the render pass we want to find or create.
	///
	/// @return		Handle to render pass.
	RenderPassHandle									GetRenderPass(
		const RenderPassCreateInfo					&	render_pass_create_info
	);

private:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @brief		Creates a new render pass.
	///
	/// @param[in]	render_pass_create_info
	///				RenderPass create info structure describing the render pass we want to create.
	///
	/// @return		Handle to render pass.
	RenderPassHandle									CreateRenderPass(
		const RenderPassCreateInfo					&	render_pass_create_info
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void												IncrementReferenceCount(
		RenderPassManagerRenderPassEntry			*	render_pass_entry
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void												DecrementReferenceCount(
		RenderPassManagerRenderPassEntry			*	render_pass_entry
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void												DestroyRenderPass(
		size_t											render_pass_hash
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void												DestroyAllRenderPasss();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	vk2d_internal::InstanceImpl						&	instance;
	Device											&	vulkan_device;

	MutexObject<RenderPassList>							render_pass_list;
};



} // vulkan
} // vk2d
