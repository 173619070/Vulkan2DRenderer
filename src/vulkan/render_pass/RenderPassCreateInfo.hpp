#pragma once

#include <core/SourceCommon.hpp>

#include <vulkan/shaders/ShaderInterface.hpp>

#include <utility/Hasher.hpp>
#include <utility/EnumHelpers.hpp>



namespace vk2d {
namespace vulkan {



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class RenderPassCreateInfo
{
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class AttachmentInfo
	{
	public:

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline									AttachmentInfo() = default;

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline									AttachmentInfo(
			VkFormat							format,
			VkSampleCountFlagBits				samples,
			VkAttachmentLoadOp					load_op,
			VkAttachmentStoreOp					store_op,
			VkAttachmentLoadOp					stencil_load_op,
			VkAttachmentStoreOp					stencil_store_op,
			VkImageLayout						initial_layout,
			VkImageLayout						final_layout
		) :
			format( format ),
			samples( samples ),
			load_op( load_op ),
			store_op( store_op ),
			stencil_load_op( stencil_load_op ),
			stencil_store_op( stencil_store_op ),
			initial_layout( initial_layout ),
			final_layout( final_layout )
		{
			hash = CalculateHash();
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline									AttachmentInfo(
			const AttachmentInfo			&	other
		) = default;

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline AttachmentInfo				&	operator=(
			const AttachmentInfo			&	other
		) = default;

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkFormat							GetFormat() const
		{
			return format;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkSampleCountFlagBits			GetSamples() const
		{
			return samples;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkAttachmentLoadOp				GetLoadOp() const
		{
			return load_op;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkAttachmentStoreOp				GetStoreOp() const
		{
			return store_op;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkAttachmentLoadOp				GetStencilLoadOp() const
		{
			return stencil_load_op;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkAttachmentStoreOp				GetStencilStoreOp() const
		{
			return stencil_store_op;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkImageLayout					GetInitialLayout() const
		{
			return initial_layout;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline VkImageLayout					GetFinalLayout() const
		{
			return final_layout;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline size_t							GetHash() const
		{
			return hash;
		}

	private:

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline size_t							CalculateHash() const
		{
			Hasher hasher;
			hasher.Hash( EnumToUnderlying( format ) );
			hasher.Hash( EnumToUnderlying( samples ) );
			hasher.Hash( EnumToUnderlying( load_op ) );
			hasher.Hash( EnumToUnderlying( store_op ) );
			hasher.Hash( EnumToUnderlying( stencil_load_op ) );
			hasher.Hash( EnumToUnderlying( stencil_store_op ) );
			hasher.Hash( EnumToUnderlying( initial_layout ) );
			hasher.Hash( EnumToUnderlying( final_layout ) );
			return hasher.GetHash();
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		VkFormat								format					= {};
		VkSampleCountFlagBits					samples					= {};
		VkAttachmentLoadOp						load_op					= {};
		VkAttachmentStoreOp						store_op				= {};
		VkAttachmentLoadOp						stencil_load_op			= {};
		VkAttachmentStoreOp						stencil_store_op		= {};
		VkImageLayout							initial_layout			= {};
		VkImageLayout							final_layout			= {};

		size_t									hash					= {};
	};



	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline 										RenderPassCreateInfo() = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline 										RenderPassCreateInfo(
		std::span<AttachmentInfo>				attachments
	) :
		attachments( attachments.begin(), attachments.end() )
	{
		hash = CalculateHash();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline 										RenderPassCreateInfo(
		const RenderPassCreateInfo			&	other
	) = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline RenderPassCreateInfo				&	operator=(
		const RenderPassCreateInfo			&	other
	) = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline bool									operator<(
		const RenderPassCreateInfo			&	other
	) const
	{
		return hash < other.GetHash();
	}

	inline const std::vector<AttachmentInfo>&	GetAttachmentInfos() const
	{
		return attachments;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline size_t								GetHash() const
	{
		return hash;
	}

private:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline size_t								CalculateHash() const
	{
		Hasher hasher;
		hasher.Hash( attachments.size() );
		for( auto & a : attachments )
		{
			hasher.Hash( a.GetHash() );
		}

		return hasher.GetHash();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	std::vector<AttachmentInfo>					attachments;

	size_t										hash;
};



} // vulkan
} // vk2d
